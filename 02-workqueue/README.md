En esta segunda parte se usa una cola de trabajo (esencialmente es lo mismo que se ha hecho en la parte 1).

Estas colas son muy útiles cuando una aplicación debe realizar tareas pesadas las cuales bloquearían nuestro servidor. Imaginemos que tenemos una api con un endpoint de tipo post donde un usuario puede subscribirse a nuestra app. Cada vez que alguien se suscribe debemos enviarle un email para que verifique su cuenta, sin embargo, esta tarea no tiene sentido hacerla en el propio endpoint pues bloqueariamos el servidor. Es más lógico enrutar los datos a una cola para que un worker haga la tarea en segundo plano.

En esta parte hacemos lo mismo que en la 01 pero simulamos una tarea con time.sleep(). Además, si levantamos muchos workers, por defecto se aplica un round-robin. Esto quiere decir que si nuestro producer genera 4 tareas y tenemos 2 workers, la primera tarea será para el worker 1, la segunda para el 2, la tercera para el 1 y la cuarta para el 2.

Además se explican los message ack(nowledgment). Si un worker muere antes de procesar un mensaje que estaba realizando, entonces se perdería este mensaje para siempre pues el servidor (cola) lo habría borrado. Aquí entran los ack, la idea es que cuando un worker termina de procesar un mensaje siempre envíe un ack al servidor, para que este sepa que efectivamente el worker ha cumplido su cometido y el mensaje se puede borrar. De esta forma, si el servidor no recibe el ack y el worker ha muerto, rabbitmq entenderá que no se ha procesado bien y lo re-encolará para que otro worker lo procese. Generalmente, aunque un worker no muera, hay un timeout de 30 minutos por el que si no se recibe el ack la tarea se re-encola.

Otro tema ocurre cuando el servidor RabbitMQ muere, pues perdemos todos los mensajes y colas por defecto. Esto se puede evitar marcando las colas y los mensaje como "duraderos".

Se podría además dar el caso en el que si todos los mensajes pares son muy pesados y todos los impares son muy pesados, tengamos un worker sobrecargado y otro no. Esto ocurre porque RabbitMQ no tiene en cuenta la carga que tiene un worker por defecto, simplemente aplica un Round Robin. Para solucionar esto podemos aplicar el protocolo basic.qos, el cual le dice a RabbitMQ que no envíe un mensaje a un worker hasta que no haya enviado un ACK de confirmación al servidor confirmando que ha terminado la tarea que estaba procesando (está libre)